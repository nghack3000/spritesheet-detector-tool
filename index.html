<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpriteSheet Frame Detector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/gifuct-js/dist/gifuct-js.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .canvas-container {
            position: relative;
        }
        canvas {
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .mode-btn.active {
            background-color: #4f46e5;
            color: white;
        }
        canvas.picking-color {
            cursor: crosshair;
        }
        #loader-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.5rem;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-5xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">SpriteSheet Frame Detector</h1>
            <p class="text-lg text-gray-600 mt-2">Upload, extract, or manually create spritesheets and their JSON data.</p>
        </header>

        <main class="bg-white rounded-2xl shadow-lg p-6 md:p-8 grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Left Column: Controls & Input -->
            <div class="flex flex-col space-y-6">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">1. Upload File</label>
                    <div class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-lg">
                        <div class="space-y-1 text-center">
                            <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true"><path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" /></svg>
                            <div class="flex text-sm text-gray-600">
                                <label for="spritesheet-upload" class="relative cursor-pointer bg-white rounded-md font-medium text-indigo-600 hover:text-indigo-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-indigo-500">
                                    <span>Upload a file</span>
                                    <input id="spritesheet-upload" name="spritesheet-upload" type="file" class="sr-only" accept="image/*">
                                </label>
                                <p class="pl-1">or drag and drop</p>
                            </div>
                            <p class="text-xs text-gray-500">PNG, JPG, GIF up to 10MB</p>
                        </div>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">2. Select Mode</label>
                    <div class="flex rounded-md shadow-sm">
                        <button id="auto-mode-btn" class="mode-btn active relative inline-flex items-center px-4 py-2 rounded-l-md border border-gray-300 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500">Auto Detect</button>
                        <button id="manual-mode-btn" class="mode-btn -ml-px relative inline-flex items-center px-4 py-2 rounded-r-md border border-gray-300 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-indigo-500 focus:border-indigo-500">Manual Select</button>
                    </div>
                </div>

                <div id="bg-color-section" class="border-t pt-4 space-y-4">
                     <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">3. Background Removal</label>
                         <div class="space-y-2">
                             <button id="ai-remove-bg-btn" class="w-full bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-purple-700 disabled:bg-gray-400">Remove Background (AI)</button>
                             <div class="flex items-center space-x-2">
                                <button id="pick-color-btn" class="w-full bg-gray-200 text-gray-800 font-semibold py-2 px-4 rounded-lg hover:bg-gray-300">Pick Color</button>
                                <div id="bg-color-swatch" class="w-10 h-10 rounded-md border border-gray-400 flex-shrink-0" style="background-color: transparent;"></div>
                             </div>
                         </div>
                     </div>
                     <div id="color-tolerance-section" style="display: none;">
                        <label for="color-tolerance" class="block text-sm font-medium text-gray-700">Color Tolerance</label>
                        <input type="range" id="color-tolerance" min="0" max="100" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                        <p class="text-xs text-gray-500 text-center mt-1">Adjusts fuzziness for color picking.</p>
                    </div>
                </div>

                <div id="auto-controls">
                     <div class="border-t pt-4 space-y-4">
                        <div>
                             <label for="sort-order" class="block text-sm font-medium text-gray-700">4. Sorting Order</label>
                             <select id="sort-order" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                 <option value="y-then-x" selected>Top-to-Bottom, then Left-to-Right</option>
                                 <option value="x-then-y">Left-to-Right, then Top-to-Bottom</option>
                             </select>
                        </div>
                        <div>
                            <label for="alpha-threshold" class="block text-sm font-medium text-gray-700">5. Alpha Threshold</label>
                            <input type="range" id="alpha-threshold" min="0" max="255" value="10" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-2">
                            <p class="text-xs text-gray-500 text-center mt-1">For transparent images. Lower is stricter.</p>
                        </div>
                     </div>
                </div>
                
                <div id="main-action-controls" class="border-t pt-4">
                     <button id="detect-button" class="w-full bg-indigo-600 text-white font-semibold py-3 px-4 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition disabled:bg-gray-400 disabled:cursor-not-allowed">Detect Frames</button>
                     <button id="clear-selection-btn" class="w-full mt-2 bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition" style="display: none;">Clear Selection</button>
                </div>

            </div>

            <!-- Right Column: Canvas & Output -->
            <div class="flex flex-col space-y-6">
                <div>
                    <h3 class="text-lg font-semibold text-gray-800 mb-2">Preview</h3>
                    <div class="canvas-container">
                        <canvas id="canvas" class="w-full border border-gray-300 rounded-lg"></canvas>
                        <div id="loader-overlay" style="display: none;">
                            <div class="loader"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Full-width JSON Output -->
            <div class="md:col-span-2 mt-4" id="output-section" style="display: none;">
                 <div class="flex justify-between items-center mb-2">
                    <h3 class="text-lg font-semibold text-gray-800">Generated Files</h3>
                    <div class="flex space-x-2">
                         <button id="download-sheet-btn" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 transition" style="display: none;">Download Spritesheet (PNG)</button>
                         <button id="download-json-btn" class="bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:bg-green-700 transition">Download JSON</button>
                    </div>
                </div>
                 <div class="relative">
                    <pre class="bg-gray-900 text-green-300 p-4 rounded-lg text-sm overflow-x-auto"><code id="json-output"></code></pre>
                    <button id="copy-json-btn" class="absolute top-2 right-2 bg-gray-700 text-white px-3 py-1 text-xs font-medium rounded hover:bg-gray-600">Copy</button>
                </div>
            </div>
            <div id="message-box" class="fixed bottom-5 right-5 bg-indigo-600 text-white py-2 px-4 rounded-lg shadow-lg" style="display: none;"></div>
        </main>
    </div>

    <script>
        // DOM Elements
        const fileInput = document.getElementById('spritesheet-upload');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loaderOverlay = document.getElementById('loader-overlay');
        const autoModeBtn = document.getElementById('auto-mode-btn');
        const manualModeBtn = document.getElementById('manual-mode-btn');
        const aiRemoveBgBtn = document.getElementById('ai-remove-bg-btn');
        const pickColorBtn = document.getElementById('pick-color-btn');
        const bgColorSwatch = document.getElementById('bg-color-swatch');
        const colorToleranceSection = document.getElementById('color-tolerance-section');
        const colorTolerance = document.getElementById('color-tolerance');
        const autoControls = document.getElementById('auto-controls');
        const sortOrder = document.getElementById('sort-order');
        const detectButton = document.getElementById('detect-button');
        const clearSelectionBtn = document.getElementById('clear-selection-btn');
        const jsonOutput = document.getElementById('json-output');
        const outputSection = document.getElementById('output-section');
        const copyJsonBtn = document.getElementById('copy-json-btn');
        const downloadJsonBtn = document.getElementById('download-json-btn');
        const downloadSheetBtn = document.getElementById('download-sheet-btn');
        const alphaThreshold = document.getElementById('alpha-threshold');
        const messageBox = document.getElementById('message-box');

        // State
        let originalImage = null;
        let originalFileName = 'spritesheet.png';
        let currentMode = 'auto'; // 'auto' or 'manual'
        let isPickingColor = false;
        let backgroundColor = null; // [r, g, b]
        let detectedFrames = [];
        let selectedFrames = [];

        // --- Mode Switching ---
        function setMode(mode) {
            currentMode = mode;
            autoModeBtn.classList.toggle('active', mode === 'auto');
            manualModeBtn.classList.toggle('active', mode === 'manual');
            
            autoControls.style.display = mode === 'auto' ? 'block' : 'none';
            detectButton.style.display = mode === 'auto' ? 'block' : 'none';
            clearSelectionBtn.style.display = mode === 'manual' ? 'block' : 'none';
            downloadSheetBtn.style.display = mode === 'manual' ? 'block' : 'none';

            resetState();
            if (originalImage) {
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 ctx.drawImage(originalImage, 0, 0);
            }
        }
        autoModeBtn.addEventListener('click', () => setMode('auto'));
        manualModeBtn.addEventListener('click', () => setMode('manual'));

        // --- File Handling ---
        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            resetState(true);
            if (file.type === 'image/gif') {
                showMessage('Processing animated GIF...');
                handleGifFile(file);
            } else {
                handleStaticImageFile(file);
            }
        }
        
        function handleStaticImageFile(file) {
            originalFileName = file.name.replace(/\.[^/.]+$/, ".png");
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    detectButton.disabled = false;
                    aiRemoveBgBtn.disabled = false;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleGifFile(file) {
            originalFileName = file.name.replace(/\.[^/.]+$/, ".png");
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const buffer = e.target.result;
                    const gif = new GIF(buffer);
                    const frames = gif.decompressFrames(true);
                    if (!frames || frames.length === 0) {
                        showMessage('Error: Could not extract frames from GIF.');
                        return;
                    }
                    const { width: frameWidth, height: frameHeight } = frames[0].dims;
                    const sheetWidth = frameWidth * frames.length;
                    const sheetHeight = frameHeight;
                    canvas.width = sheetWidth;
                    canvas.height = sheetHeight;
                    ctx.clearRect(0, 0, sheetWidth, sheetHeight);
                    let fullImageData = ctx.createImageData(sheetWidth, sheetHeight);
                    
                    frames.forEach((frame, i) => {
                         const frameImageData = new ImageData(frame.patch, frame.dims.width, frame.dims.height);
                         const startX = frame.dims.left + i * frameWidth;
                         const startY = frame.dims.top;

                         for (let y = 0; y < frame.dims.height; y++) {
                            for (let x = 0; x < frame.dims.width; x++) {
                                const patchIdx = (y * frame.dims.width + x) * 4;
                                const fullIdx = ((startY + y) * sheetWidth + (startX + x)) * 4;
                                fullImageData.data[fullIdx] = frameImageData.data[patchIdx];
                                fullImageData.data[fullIdx + 1] = frameImageData.data[patchIdx + 1];
                                fullImageData.data[fullIdx + 2] = frameImageData.data[patchIdx + 2];
                                fullImageData.data[fullIdx + 3] = frameImageData.data[patchIdx + 3];
                            }
                        }
                    });
                    ctx.putImageData(fullImageData, 0, 0);

                    const img = new Image();
                    img.onload = () => {
                        originalImage = img;
                        detectButton.disabled = false;
                        aiRemoveBgBtn.disabled = false;
                        outputSection.style.display = 'none';
                        showMessage('GIF converted to spritesheet. Ready to detect frames.');
                    };
                    img.src = canvas.toDataURL();
                } catch (error) {
                    console.error("GIF parsing error:", error);
                    showMessage('Error: Failed to parse GIF file.');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
        const dropZone = fileInput.closest('.border-dashed');
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('border-indigo-500', 'bg-indigo-50'); });
        dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.classList.remove('border-indigo-500', 'bg-indigo-50'); });
        dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('border-indigo-500', 'bg-indigo-50'); handleFile(e.dataTransfer.files[0]); });

        // --- Background Removal ---
        aiRemoveBgBtn.addEventListener('click', async () => {
            if (!originalImage) {
                showMessage("Please upload an image first.");
                return;
            }
            loaderOverlay.style.display = 'flex';
            try {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = originalImage.width;
                tempCanvas.height = originalImage.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(originalImage, 0, 0);
                const base64Image = tempCanvas.toDataURL('image/png');

                const response = await fetch("https://gradio-demo-rembg.hf.space/run/predict", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        data: [base64Image]
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                const result = await response.json();
                const newBase64Image = result.data[0];

                const img = new Image();
                img.onload = () => {
                    originalImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    resetState();
                    showMessage("AI background removal successful!");
                };
                img.src = newBase64Image;

            } catch (error) {
                console.error("AI Background Removal Error:", error);
                showMessage("AI background removal failed. Please try again.");
            } finally {
                loaderOverlay.style.display = 'none';
            }
        });

        pickColorBtn.addEventListener('click', () => {
            if (!originalImage) {
                showMessage("Please upload an image first.");
                return;
            }
            isPickingColor = true;
            canvas.classList.add('picking-color');
            showMessage("Click on the background color in the preview.");
        });

        canvas.addEventListener('click', (e) => {
            if (!originalImage) return;
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
            const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));

            if (isPickingColor) {
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                backgroundColor = [pixel[0], pixel[1], pixel[2]];
                bgColorSwatch.style.backgroundColor = `rgb(${backgroundColor[0]}, ${backgroundColor[1]}, ${backgroundColor[2]})`;
                isPickingColor = false;
                canvas.classList.remove('picking-color');
                colorToleranceSection.style.display = 'block';
                showMessage(`Background color set to rgb(${backgroundColor.join(', ')}).`);
            } else if (currentMode === 'manual') {
                handleManualSelection(x, y);
            }
        });

        // --- Frame Detection ---
        function findFrameBounds(startX, startY, width, height, data, visited) {
            const queue = [[startX, startY]];
            let minX = startX, maxX = startX, minY = startY, maxY = startY;
            let head = 0;
            const alphaThresh = parseInt(alphaThreshold.value, 10);
            const colorTol = parseInt(colorTolerance.value, 10);
            const isPixelPartOfSprite = (px, py) => {
                const index = (py * width + px) * 4;
                if (backgroundColor) {
                    const r = data[index], g = data[index+1], b = data[index+2];
                    const distance = Math.sqrt(Math.pow(r - backgroundColor[0], 2) + Math.pow(g - backgroundColor[1], 2) + Math.pow(b - backgroundColor[2], 2));
                    return distance > colorTol;
                } else {
                    return data[index + 3] > alphaThresh;
                }
            };
            if (startX < 0 || startX >= width || startY < 0 || startY >= height || !isPixelPartOfSprite(startX, startY)) return null;
            while(head < queue.length) {
                const [x, y] = queue[head++];
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                const index = (y * width + x);
                if (visited[index] || !isPixelPartOfSprite(x,y)) continue;
                visited[index] = true;
                minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                minY = Math.min(minY, y); maxY = Math.max(maxY, y);
                queue.push([x + 1, y]); queue.push([x - 1, y]);
                queue.push([x, y + 1]); queue.push([x, y - 1]);
            }
            return { x: minX, y: minY, w: maxX - minX + 1, h: maxY - minY + 1 };
        }
        
        detectButton.addEventListener('click', () => {
            if (!originalImage) return;
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const visited = new Array(canvas.width * canvas.height).fill(false);
            const frames = [];
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    if (!visited[y * canvas.width + x]) {
                        const frame = findFrameBounds(x, y, canvas.width, canvas.height, imageData.data, visited);
                        if (frame) frames.push(frame);
                    }
                }
            }
            const sortValue = sortOrder.value;
            if (sortValue === 'y-then-x') frames.sort((a,b) => (a.y - b.y) || (a.x - b.x));
            else frames.sort((a,b) => (a.x - b.x) || (a.y - b.y));
            detectedFrames = frames;
            redrawCanvas();
            const imageName = originalFileName.replace(/\.[^/.]+$/, ".png");
            generateJson(detectedFrames, { w: canvas.width, h: canvas.height }, imageName);
        });

        function handleManualSelection(x, y) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const visited = new Array(canvas.width * canvas.height).fill(false);
            const frame = findFrameBounds(x, y, canvas.width, canvas.height, imageData.data, visited);
            if (frame) {
                const alreadyExists = selectedFrames.some(f => f.x === frame.x && f.y === frame.y && f.w === frame.w && f.h === frame.h);
                if (!alreadyExists) {
                    selectedFrames.push(frame);
                    redrawCanvas();
                    updateManualModeOutput();
                }
            }
        }
        
        clearSelectionBtn.addEventListener('click', () => {
            selectedFrames = [];
            redrawCanvas();
            outputSection.style.display = 'none';
        });

        // --- Drawing & JSON ---
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0);
            const framesToDraw = currentMode === 'auto' ? detectedFrames : selectedFrames;
            drawFrameRectsAndNumbers(framesToDraw);
        }

        function drawFrameRectsAndNumbers(frames) {
            ctx.strokeStyle = 'rgba(255, 0, 255, 1)';
            ctx.lineWidth = 1.5;
            ctx.font = 'bold 12px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            frames.forEach((frame, i) => {
                ctx.strokeRect(frame.x - 0.5, frame.y - 0.5, frame.w, frame.h);
                const text = String(i);
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width, textHeight = 12;
                const rectPadding = 4;
                const rectX = frame.x + 2, rectY = frame.y + 2;
                
                ctx.fillStyle = 'rgba(255, 0, 255, 0.85)';
                ctx.fillRect(rectX, rectY, textWidth + rectPadding, textHeight + rectPadding / 2);
                ctx.fillStyle = 'white';
                ctx.fillText(text, rectX + (textWidth + rectPadding) / 2, rectY + (textHeight + rectPadding / 2) / 2);
            });
        }
        
        function getManualLayout() {
            if (selectedFrames.length === 0) return null;
            const maxWidth = Math.max(...selectedFrames.map(f => f.w));
            const maxHeight = Math.max(...selectedFrames.map(f => f.h));
            const newSheetSize = { w: maxWidth * selectedFrames.length, h: maxHeight };
            const newFrames = selectedFrames.map((frame, i) => ({
                sourceX: frame.x, sourceY: frame.y,
                destX: i * maxWidth + Math.floor((maxWidth - frame.w) / 2),
                destY: Math.floor((maxHeight - frame.h) / 2),
                w: frame.w, h: frame.h
            }));
            return { newSheetSize, newFrames };
        }
        
        function updateManualModeOutput() {
            const layout = getManualLayout();
            if (!layout) {
                 outputSection.style.display = 'none';
                 return;
            }
            const { newSheetSize, newFrames } = layout;
            const jsonFrames = newFrames.map(f => ({ x: f.destX, y: f.destY, w: f.w, h: f.h }));
            const newImageName = originalFileName.replace(/\.[^/.]+$/, "_extracted.png");
            generateJson(jsonFrames, newSheetSize, newImageName);
        }

        function generateJson(frames, sheetSize, imageName) {
            if (!frames || frames.length === 0) {
                 outputSection.style.display = 'none';
                 return;
            }
            const phaserJson = { frames: {}, meta: { image: imageName, size: sheetSize, scale: "1" } };
            frames.forEach((frame, i) => {
                const frameName = `${imageName.replace('.png','')}_${String(i).padStart(3, '0')}.png`;
                phaserJson.frames[frameName] = {
                    frame: { x: frame.x, y: frame.y, w: frame.w, h: frame.h },
                    rotated: false, trimmed: false,
                    spriteSourceSize: { x: 0, y: 0, w: frame.w, h: frame.h },
                    sourceSize: { w: frame.w, h: frame.h }
                };
            });
            jsonOutput.textContent = JSON.stringify(phaserJson, null, '\t');
            outputSection.style.display = 'block';
        }

        downloadJsonBtn.addEventListener('click', () => {
            if ((currentMode === 'manual' && selectedFrames.length === 0) || (currentMode === 'auto' && detectedFrames.length === 0)) {
                showMessage("Please select or detect some frames first."); return;
            }
            const jsonString = jsonOutput.textContent;
            if(!jsonString || jsonString.trim() === '') return;
            const blob = new Blob([jsonString], { type: 'application/json' });
            const jsonFileName = (currentMode === 'manual') 
                ? originalFileName.replace(/\.[^/.]+$/, "_extracted.json") 
                : originalFileName.replace(/\.[^/.]+$/, ".json");
            triggerDownload(blob, jsonFileName);
        });

        downloadSheetBtn.addEventListener('click', () => {
            const layout = getManualLayout();
            if (!layout) { showMessage("Please select some frames first."); return; }
            const { newSheetSize, newFrames } = layout;
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = newSheetSize.w;
            tempCanvas.height = newSheetSize.h;
            const tempCtx = tempCanvas.getContext('2d');
            const colorTol = parseInt(colorTolerance.value, 10);

            newFrames.forEach(frame => {
                const tempFrameCanvas = document.createElement('canvas');
                tempFrameCanvas.width = frame.w;
                tempFrameCanvas.height = frame.h;
                const tempFrameCtx = tempFrameCanvas.getContext('2d');
                
                tempFrameCtx.drawImage(originalImage, frame.sourceX, frame.sourceY, frame.w, frame.h, 0, 0, frame.w, frame.h);

                if (backgroundColor) {
                    const imgData = tempFrameCtx.getImageData(0, 0, frame.w, frame.h);
                    for (let p = 0; p < imgData.data.length; p += 4) {
                        const distance = Math.sqrt(Math.pow(imgData.data[p] - backgroundColor[0], 2) + Math.pow(imgData.data[p+1] - backgroundColor[1], 2) + Math.pow(imgData.data[p+2] - backgroundColor[2], 2));
                        if (distance <= colorTol) {
                            imgData.data[p+3] = 0;
                        }
                    }
                    tempFrameCtx.putImageData(imgData, 0, 0);
                }
                
                tempCtx.drawImage(tempFrameCanvas, frame.destX, frame.destY);
            });
            
            tempCanvas.toBlob((blob) => {
                triggerDownload(blob, originalFileName.replace(/\.[^/.]+$/, "_extracted.png"));
            });
        });

        // --- Utilities ---
        function resetState(fullReset = false) {
             detectedFrames = [];
             selectedFrames = [];
             outputSection.style.display = 'none';
             if (originalImage) {
                 ctx.clearRect(0,0,canvas.width, canvas.height);
                 ctx.drawImage(originalImage, 0, 0);
             }
             if (fullReset) {
                 originalImage = null;
                 backgroundColor = null;
                 bgColorSwatch.style.backgroundColor = 'transparent';
                 colorToleranceSection.style.display = 'none';
                 detectButton.disabled = true;
                 aiRemoveBgBtn.disabled = true;
                 ctx.clearRect(0,0,canvas.width, canvas.height);
             }
        }
        
        function showMessage(message) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => { messageBox.style.display = 'none'; }, 3000);
        }
        
        function triggerDownload(blob, fileName) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        copyJsonBtn.addEventListener('click', () => {
            const textarea = document.createElement('textarea');
            textarea.value = jsonOutput.textContent;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            showMessage('JSON copied to clipboard!');
        });

        // Init
        setMode('auto');
        detectButton.disabled = true;
        aiRemoveBgBtn.disabled = true;
    </script>
</body>
</html>


